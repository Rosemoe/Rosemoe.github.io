<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用Android RenderNode加速绘制 | Rosemoe的小博客</title><meta name="author" content="Rosemoe"><meta name="copyright" content="Rosemoe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面的废话研究RenderNode的起因…作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成">
<meta property="og:type" content="article">
<meta property="og:title" content="使用Android RenderNode加速绘制">
<meta property="og:url" content="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/index.html">
<meta property="og:site_name" content="Rosemoe的小博客">
<meta property="og:description" content="写在前面的废话研究RenderNode的起因…作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.rosemoe.cyou/img/default_cover/5.jpg">
<meta property="article:published_time" content="2021-10-02T11:57:08.000Z">
<meta property="article:modified_time" content="2021-10-09T17:17:52.918Z">
<meta property="article:author" content="Rosemoe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.rosemoe.cyou/img/default_cover/5.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用Android RenderNode加速绘制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-10 01:17:52',
  highlightLangExpand: 'null',
  highlightLangCollapse: 'cpp'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom_styles.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover/5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Rosemoe的小博客"><span class="site-name">Rosemoe的小博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用Android RenderNode加速绘制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-02T11:57:08.000Z" title="发表于 2021-10-02 19:57:08">2021-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-09T17:17:52.918Z" title="更新于 2021-10-10 01:17:52">2021-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用Android RenderNode加速绘制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="写在前面的废话"><a href="#写在前面的废话" class="headerlink" title="写在前面的废话"></a>写在前面的废话</h2><h3 id="研究RenderNode的起因…"><a href="#研究RenderNode的起因…" class="headerlink" title="研究RenderNode的起因…"></a>研究RenderNode的起因…</h3><p>作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。<br>于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成了普普通通的文本绘制，但是就是比不上EditText。笔者一下子就十分纳闷了，于是开始摸TextView的绘制部分。</p>
<h3 id="摸索TextView源码…"><a href="#摸索TextView源码…" class="headerlink" title="摸索TextView源码…"></a>摸索TextView源码…</h3><p>下面以Andoird Q的源码为例。<br>打开<code>onDraw()</code>方法翻了一会，看到了调用<code>Layout</code>绘制的代码，不过伴随着的还有<code>mEditor</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">highlight</span> <span class="operator">=</span> getUpdatedHighlightPath();</span><br><span class="line"><span class="keyword">if</span> (mEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">    mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mEditor</code>是在TextView能编辑文本的时候创建的，显然我应该看Editor.java了<del>（但是我还是先看了一下Layout，可能我是sb吧）</del><br>然后转到<code>Editor#onDraw</code>:<br>本来以为会很长却意外地短，一下子就看到再次调方法绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mTextView.canHaveDisplayList() &amp;&amp; canvas.isHardwareAccelerated()) &#123;</span><br><span class="line">    drawHardwareAccelerated(canvas, layout, highlight, highlightPaint,</span><br><span class="line">            cursorOffsetVertical);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layout.draw(canvas, highlight, highlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HardwareAccelerated</code>实在是一个敏感的字眼，于是又看<code>Editor#drawHardwareAccelerated</code>,追踪到<code>drawHardwareAcceleratedInner</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RenderNode</span> <span class="variable">blockDisplayList</span> <span class="operator">=</span> mTextRenderNodes[blockIndex].renderNode;</span><br><span class="line"><span class="keyword">if</span> (mTextRenderNodes[blockIndex].needsToBeShifted || blockDisplayListIsInvalid) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">blockBeginLine</span> <span class="operator">=</span> blockInfoIndex == <span class="number">0</span> ?</span><br><span class="line">            <span class="number">0</span> : blockEndLines[blockInfoIndex - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> layout.getLineTop(blockBeginLine);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> layout.getLineBottom(blockEndLine);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> mTextView.getWidth();</span><br><span class="line">    <span class="keyword">if</span> (mTextView.getHorizontallyScrolling()) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">min</span> <span class="operator">=</span> Float.MAX_VALUE;</span><br><span class="line">        <span class="type">float</span> <span class="variable">max</span> <span class="operator">=</span> Float.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">line</span> <span class="operator">=</span> blockBeginLine; line &lt;= blockEndLine; line++) &#123;</span><br><span class="line">            min = Math.min(min, layout.getLineLeft(line));</span><br><span class="line">            max = Math.max(max, layout.getLineRight(line));</span><br><span class="line">        &#125;</span><br><span class="line">        left = (<span class="type">int</span>) min;</span><br><span class="line">        right = (<span class="type">int</span>) (max + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild display list if it is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (blockDisplayListIsInvalid) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RecordingCanvas</span> <span class="variable">recordingCanvas</span> <span class="operator">=</span> blockDisplayList.beginRecording(</span><br><span class="line">                right - left, bottom - top);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// drawText is always relative to TextView&#x27;s origin, this translation</span></span><br><span class="line">            <span class="comment">// brings this range of text back to the top left corner of the viewport</span></span><br><span class="line">            recordingCanvas.translate(-left, -top);</span><br><span class="line">            layout.drawText(recordingCanvas, blockBeginLine, blockEndLine);</span><br><span class="line">            mTextRenderNodes[blockIndex].isDirty = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// No need to untranslate, previous context is popped after</span></span><br><span class="line">            <span class="comment">// drawDisplayList</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            blockDisplayList.endRecording();</span><br><span class="line">            <span class="comment">// Same as drawDisplayList below, handled by our TextView&#x27;s parent</span></span><br><span class="line">            blockDisplayList.setClipToBounds(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Valid display list only needs to update its drawing location.</span></span><br><span class="line">    blockDisplayList.setLeftTopRightBottom(left, top, right, bottom);</span><br><span class="line">    mTextRenderNodes[blockIndex].needsToBeShifted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">((RecordingCanvas) canvas).drawRenderNode(blockDisplayList);</span><br></pre></td></tr></table></figure>
<p>看到DisplayList、RenderNode，我感觉大有搞头。经过一段时间的翻阅后，发现RenderNode在Android Q（API 29）上成为了公开的API，位于<code>android.graphics</code>下。在这之前，RenderNode是<code>android.view</code>下的Hidden API，而且看了一下Android L的代码和Android P的代码相差还挺大的，反射也不好反射。不过我还是尝试在Android R上使用它。</p>
<h2 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h2><p>应该没人翻译文档吧？稍微翻译一下…</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>RenderNode可用于构建硬件加速绘制体系。每个RenderNode既包含一个DisplayList也包含一系列影响其DisplayList如何绘制在屏幕上的属性。RenderNode在默认情况下在所有View上被内部使用，而并不是直接被使用。<br>RenderNode可用于将一个复杂的绘制场景分开成为更小的部分。这些部分就可以被单独地以更小地开销更新。更新这一场景地一部分只需要更新少数的RenderNode的DisplayList或者属性，而不是重绘所有。一个RenderNode只需要在它的内容被改变时重新录制它的DisplayList。RenderNode可以在不重新录制的情况下通过它的属性进行一些变换。<br>比如说，一个文本编辑器或许会保存每一段到它自己的RenderNode中。这样当用户插入或删除一些字符的时候，只有受影响的段落的DisplayList需要被重新录制。</p>
<h4 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h4><p>RenderNode可以在<code>RecordingCanvas</code>上被绘制。这不受软件绘制支持。请确保你正在使用来绘制RenderNode的Canvas时启用硬件加速的。你可以通过<code>Canvas.isHardwareAccelerated()</code>来确认硬件加速是否可用。</p>
<h4 id="创建RenderNode"><a href="#创建RenderNode" class="headerlink" title="创建RenderNode"></a>创建RenderNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RenderNode</span>(<span class="string">&quot;myRenderNode&quot;</span>);</span><br><span class="line">renderNode.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 设置大小为50*50</span></span><br><span class="line"><span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.beginRecording();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在RenderNode的Canvas上绘制</span></span><br><span class="line">    canvas.drawRect(...);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    renderNode.endRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在View中绘制RenderNode"><a href="#在View中绘制RenderNode" class="headerlink" title="在View中绘制RenderNode"></a>在View中绘制RenderNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated()) &#123;</span><br><span class="line">        <span class="comment">// 检查RenderNode是否有显示列表。如果没有，先重新绘制RenderNode</span></span><br><span class="line">        <span class="keyword">if</span> (!myRenderNode.hasDisplayList()) &#123;</span><br><span class="line">            updateDisplayList(myRenderNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将RenderNode画到Canvas上</span></span><br><span class="line">        canvas.drawRenderNode(myRenderNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>这一步并不是必须的，但是如果你想要尽快释放被DisplayList占用的资源，我们推荐你这么做。最主要的是它或许包含的Bitmap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 舍弃DisplayList，释放持有的资源</span></span><br><span class="line">renderNode.discardDisplayList();</span><br></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除此以外，RenderNode提供了许多属性，比如<code>setScaleX(float)</code>和<code>setTranslationX(float)</code>。他们可以用来影响一切已经记录的绘制命令。例如，这些属性可以被用来移动大量的图像，而不需要重新通过一个一个单独调用<code>canvas.drawBitmap()</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createDisplayList</span><span class="params">()</span> &#123;</span><br><span class="line">    mRenderNode = <span class="keyword">new</span> <span class="title class_">RenderNode</span>(<span class="string">&quot;MyRenderNode&quot;</span>);</span><br><span class="line">    mRenderNode.setPosition(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mRenderNode.beginRecording();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Bitmap b : mBitmaps) &#123;</span><br><span class="line">            canvas.drawBitmap(b, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="literal">null</span>);</span><br><span class="line">            canvas.translate(<span class="number">0.0f</span>, b.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mRenderNode.endRecording();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated())</span><br><span class="line">        canvas.drawRenderNode(mRenderNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveContentBy</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">// 这将移动所有记录在RenderNode中的图像向右边x像素，然后重绘这个View</span></span><br><span class="line">     <span class="comment">// 所有记录的操作不需要被重新发行，只有onDraw()会被调用而且很快就执行完成</span></span><br><span class="line">     mRenderNode.offsetLeftAndRight(x);</span><br><span class="line">     invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：此处笔者觉得用处不大，没翻译<br>A few of the properties may at first appear redundant, such as setElevation(float) and setTranslationZ(float). The reason for these duplicates are to allow for a separation between static &amp; transient usages. For example consider a button that raises from 2dp to 8dp when pressed. To achieve that an application may decide to setElevation(2dip), and then on press to animate setTranslationZ to 6dip. Combined this achieves the final desired 8dip value, but the animation need only concern itself with animating the lift from press without needing to know the initial starting value. setTranslationX(float) and setTranslationY(float) are similarly provided for animation uses despite the functional overlap with setPosition(Rect).<br>The RenderNode’s transform matrix is computed at render time as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Matrix</span> <span class="variable">transform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">transform.setTranslate(renderNode.getTranslationX(), renderNode.getTranslationY());</span><br><span class="line">transform.preRotate(renderNode.getRotationZ(),</span><br><span class="line">        renderNode.getPivotX(), renderNode.getPivotY());</span><br><span class="line">transform.preScale(renderNode.getScaleX(), renderNode.getScaleY(),</span><br><span class="line">        renderNode.getPivotX(), renderNode.getPivotY());</span><br></pre></td></tr></table></figure>
<p>The current canvas transform matrix, which is translated to the RenderNode’s position, is then multiplied by the RenderNode’s transform matrix. Therefore the ordering of calling property setters does not affect the result. That is to say that:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderNode.setTranslationX(<span class="number">100</span>);</span><br><span class="line">renderNode.setScaleX(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>is equivalent to:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderNode.setScaleX(<span class="number">100</span>);</span><br><span class="line">renderNode.setTranslationX(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>RenderNode可以在任何线程被创建并使用，但它不是线程安全的。只有一个线程可以在某一时间与RenderNode交互。建议RenderNode只在相同的线程被使用，即它将要被绘制的线程。比如自定义View使用RenderNode时，只在UI线程使用RenderNode。<br>RenderNode的许多方法返回一个布尔值来指示它是否需要被重绘。典型的比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translateTo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsUpdate</span> <span class="operator">=</span> myRenderNode.setTranslationX(x);</span><br><span class="line">    needsUpdate |= myRenderNode.setTranslationY(y);</span><br><span class="line">    <span class="keyword">if</span> (needsUpdate) &#123;</span><br><span class="line">        myOwningView.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会比显式地通过<code>getTransationX()</code>比较检查快，因为这最小化了移动到地JNI开销。是否需要重绘取决于这个RenderNode如何被绘制。如果它被绘制到View上，那么只需要重绘View就行了。如果它被绘制到一个直接使用<code>Surface.lockHardwareCanvas()</code>的Canvas上，那么它需要被重绘，通过调用<code>Surface.lockHardwareCanvas()</code>，绘制根RenderNode或者其它被顶级内容需要的，并调用<code>Surface.unlockCanvasAndPost(canvas)</code>。</p>
<h3 id="几个提示"><a href="#几个提示" class="headerlink" title="几个提示"></a>几个提示</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器的name可以随意，null也可以。文档说是调试用的。</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>绘制到View的Canvas上之前，一定要记得检查这个Canvas是否开启硬件加速，如果没有开启，那么RenderNode无法被绘制并且会抛出UnsupportedOperationException。<br>同时也要检查RenderNode是否还有DisplayList，通过<code>RenderNode.hasDisplayList()</code>。如果返回false，需要重新录制在RenderNode上的绘制操作，否则绘制出的RenderNode是空的。<br>RenderNode似乎如果在上一次绘制操作中没有被使用，其DisplayList就会被回收，需要重新录制操作。笔者因为不知道这个傻傻地调了一个小时，最后才发现是没有DisplayList。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><a target="_blank" rel="noopener" href="https://github.com/Rosemoe/CodeEditor/blob/main/editor/src/main/java/io/github/rosemoe/sora/widget/HwAcceleratedRenderer.java">HwAcceleratedRenderer.java</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.rosemoe.cyou">Rosemoe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/">https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.rosemoe.cyou" target="_blank">Rosemoe的小博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/24/whut-2022-autumn-c-answer/" title="WHUT2022秋C语言A类答案"><img class="cover" src="/img/default_cover/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WHUT2022秋C语言A类答案</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/22/editor-get-started/" title="Sora-editor - Get started"><img class="cover" src="/img/default_cover/16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sora-editor - Get started</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rosemoe</div><div class="author-info__description">A lazy Android developer</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Rosemoe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Rosemoe" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="javascript:copyEmail();" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Rosemoe的小博客~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E5%BA%9F%E8%AF%9D"><span class="toc-number">1.</span> <span class="toc-text">写在前面的废话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6RenderNode%E7%9A%84%E8%B5%B7%E5%9B%A0%E2%80%A6"><span class="toc-number">1.1.</span> <span class="toc-text">研究RenderNode的起因…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%B8%E7%B4%A2TextView%E6%BA%90%E7%A0%81%E2%80%A6"><span class="toc-number">1.2.</span> <span class="toc-text">摸索TextView源码…</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderNode"><span class="toc-number">2.</span> <span class="toc-text">RenderNode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">2.1.</span> <span class="toc-text">文档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">硬件加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BARenderNode"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建RenderNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8View%E4%B8%AD%E7%BB%98%E5%88%B6RenderNode"><span class="toc-number">2.1.3.</span> <span class="toc-text">在View中绘制RenderNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.4.</span> <span class="toc-text">释放资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.5.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.1.6.</span> <span class="toc-text">线程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%8F%90%E7%A4%BA"><span class="toc-number">2.2.</span> <span class="toc-text">几个提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/codeforces-888/" title="Codeforces Round 888 (Div.3) A-G 题解"><img src="/img/default_cover/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 888 (Div.3) A-G 题解"/></a><div class="content"><a class="title" href="/2023/07/26/codeforces-888/" title="Codeforces Round 888 (Div.3) A-G 题解">Codeforces Round 888 (Div.3) A-G 题解</a><time datetime="2023-07-26T07:05:22.000Z" title="发表于 2023-07-26 15:05:22">2023-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/atcoder-abc311/" title="AtCoder Beginner Contest 311 A-E 题解"><img src="/img/default_cover/17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AtCoder Beginner Contest 311 A-E 题解"/></a><div class="content"><a class="title" href="/2023/07/24/atcoder-abc311/" title="AtCoder Beginner Contest 311 A-E 题解">AtCoder Beginner Contest 311 A-E 题解</a><time datetime="2023-07-24T07:23:33.000Z" title="发表于 2023-07-24 15:23:33">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/23/atcoder-abc310/" title="AtCoder Beginner Contest 310 A-F 题解"><img src="/img/default_cover/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AtCoder Beginner Contest 310 A-F 题解"/></a><div class="content"><a class="title" href="/2023/07/23/atcoder-abc310/" title="AtCoder Beginner Contest 310 A-F 题解">AtCoder Beginner Contest 310 A-F 题解</a><time datetime="2023-07-23T13:34:35.000Z" title="发表于 2023-07-23 21:34:35">2023-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/whut-2022-autumn-c-answer/" title="WHUT2022秋C语言A类答案"><img src="/img/default_cover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WHUT2022秋C语言A类答案"/></a><div class="content"><a class="title" href="/2022/10/24/whut-2022-autumn-c-answer/" title="WHUT2022秋C语言A类答案">WHUT2022秋C语言A类答案</a><time datetime="2022-10-24T09:45:05.000Z" title="发表于 2022-10-24 17:45:05">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/02/android-render-node-using/" title="使用Android RenderNode加速绘制"><img src="/img/default_cover/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Android RenderNode加速绘制"/></a><div class="content"><a class="title" href="/2021/10/02/android-render-node-using/" title="使用Android RenderNode加速绘制">使用Android RenderNode加速绘制</a><time datetime="2021-10-02T11:57:08.000Z" title="发表于 2021-10-02 19:57:08">2021-10-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Rosemoe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">にゃん~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async src="/js/sideloaded.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="にゃん~,喵~" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
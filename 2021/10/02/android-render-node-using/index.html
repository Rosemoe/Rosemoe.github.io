<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用Android RenderNode加速绘制 | Rosemoe的小博客</title><meta name="author" content="Rosemoe"><meta name="copyright" content="Rosemoe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面的废话研究RenderNode的起因…作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成">
<meta property="og:type" content="article">
<meta property="og:title" content="使用Android RenderNode加速绘制">
<meta property="og:url" content="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/index.html">
<meta property="og:site_name" content="Rosemoe的小博客">
<meta property="og:description" content="写在前面的废话研究RenderNode的起因…作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.rosemoe.cyou/img/posts/android-render-node-using/cover.jpg">
<meta property="article:published_time" content="2021-10-02T11:57:08.000Z">
<meta property="article:modified_time" content="2025-06-22T17:34:28.336Z">
<meta property="article:author" content="Rosemoe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.rosemoe.cyou/img/posts/android-render-node-using/cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "使用Android RenderNode加速绘制",
  "url": "https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/",
  "image": "https://blog.rosemoe.cyou/img/posts/android-render-node-using/cover.jpg",
  "datePublished": "2021-10-02T11:57:08.000Z",
  "dateModified": "2025-06-22T17:34:28.336Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rosemoe",
      "url": "https://blog.rosemoe.cyou"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'https://fancyapps.com/fancybox/',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用Android RenderNode加速绘制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom_styles.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/posts/android-render-node-using/cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Rosemoe的小博客</span></a><a class="nav-page-title" href="/"><span class="site-name">使用Android RenderNode加速绘制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">使用Android RenderNode加速绘制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-02T11:57:08.000Z" title="发表于 2021-10-02 19:57:08">2021-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-22T17:34:28.336Z" title="更新于 2025-06-23 01:34:28">2025-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="写在前面的废话"><a href="#写在前面的废话" class="headerlink" title="写在前面的废话"></a>写在前面的废话</h2><h3 id="研究RenderNode的起因…"><a href="#研究RenderNode的起因…" class="headerlink" title="研究RenderNode的起因…"></a>研究RenderNode的起因…</h3><p>作为一个代码编辑器的开发者，我十分关注我写的View的绘制速度。<br>于是国庆节放假，心血来潮测试自己编辑器和EditText绘制的性能。发现一段代码，在两个View中显示出来几乎没什么区别，但是TextView的绘制比咱快多了，这是为什么呢？我尝试一段一段注释自己的除了文本以外元素的绘制代码。从屏蔽代码区划线，到屏蔽空白字符的绘制，最后甚至把代码高亮都换成了普普通通的文本绘制，但是就是比不上EditText。笔者一下子就十分纳闷了，于是开始摸TextView的绘制部分。</p>
<h3 id="摸索TextView源码…"><a href="#摸索TextView源码…" class="headerlink" title="摸索TextView源码…"></a>摸索TextView源码…</h3><p>下面以Andoird Q的源码为例。<br>打开<code>onDraw()</code>方法翻了一会，看到了调用<code>Layout</code>绘制的代码，不过伴随着的还有<code>mEditor</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">highlight</span> <span class="operator">=</span> getUpdatedHighlightPath();</span><br><span class="line"><span class="keyword">if</span> (mEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">    mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mEditor</code>是在TextView能编辑文本的时候创建的，显然我应该看Editor.java了<del>（但是我还是先看了一下Layout，可能我是sb吧）</del><br>然后转到<code>Editor#onDraw</code>:<br>本来以为会很长却意外地短，一下子就看到再次调方法绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mTextView.canHaveDisplayList() &amp;&amp; canvas.isHardwareAccelerated()) &#123;</span><br><span class="line">    drawHardwareAccelerated(canvas, layout, highlight, highlightPaint,</span><br><span class="line">            cursorOffsetVertical);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layout.draw(canvas, highlight, highlightPaint, cursorOffsetVertical);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HardwareAccelerated</code>实在是一个敏感的字眼，于是又看<code>Editor#drawHardwareAccelerated</code>,追踪到<code>drawHardwareAcceleratedInner</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RenderNode</span> <span class="variable">blockDisplayList</span> <span class="operator">=</span> mTextRenderNodes[blockIndex].renderNode;</span><br><span class="line"><span class="keyword">if</span> (mTextRenderNodes[blockIndex].needsToBeShifted || blockDisplayListIsInvalid) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">blockBeginLine</span> <span class="operator">=</span> blockInfoIndex == <span class="number">0</span> ?</span><br><span class="line">            <span class="number">0</span> : blockEndLines[blockInfoIndex - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> layout.getLineTop(blockBeginLine);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> layout.getLineBottom(blockEndLine);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> mTextView.getWidth();</span><br><span class="line">    <span class="keyword">if</span> (mTextView.getHorizontallyScrolling()) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">min</span> <span class="operator">=</span> Float.MAX_VALUE;</span><br><span class="line">        <span class="type">float</span> <span class="variable">max</span> <span class="operator">=</span> Float.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">line</span> <span class="operator">=</span> blockBeginLine; line &lt;= blockEndLine; line++) &#123;</span><br><span class="line">            min = Math.min(min, layout.getLineLeft(line));</span><br><span class="line">            max = Math.max(max, layout.getLineRight(line));</span><br><span class="line">        &#125;</span><br><span class="line">        left = (<span class="type">int</span>) min;</span><br><span class="line">        right = (<span class="type">int</span>) (max + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild display list if it is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (blockDisplayListIsInvalid) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RecordingCanvas</span> <span class="variable">recordingCanvas</span> <span class="operator">=</span> blockDisplayList.beginRecording(</span><br><span class="line">                right - left, bottom - top);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// drawText is always relative to TextView&#x27;s origin, this translation</span></span><br><span class="line">            <span class="comment">// brings this range of text back to the top left corner of the viewport</span></span><br><span class="line">            recordingCanvas.translate(-left, -top);</span><br><span class="line">            layout.drawText(recordingCanvas, blockBeginLine, blockEndLine);</span><br><span class="line">            mTextRenderNodes[blockIndex].isDirty = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// No need to untranslate, previous context is popped after</span></span><br><span class="line">            <span class="comment">// drawDisplayList</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            blockDisplayList.endRecording();</span><br><span class="line">            <span class="comment">// Same as drawDisplayList below, handled by our TextView&#x27;s parent</span></span><br><span class="line">            blockDisplayList.setClipToBounds(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Valid display list only needs to update its drawing location.</span></span><br><span class="line">    blockDisplayList.setLeftTopRightBottom(left, top, right, bottom);</span><br><span class="line">    mTextRenderNodes[blockIndex].needsToBeShifted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">((RecordingCanvas) canvas).drawRenderNode(blockDisplayList);</span><br></pre></td></tr></table></figure>
<p>看到DisplayList、RenderNode，我感觉大有搞头。经过一段时间的翻阅后，发现RenderNode在Android Q（API 29）上成为了公开的API，位于<code>android.graphics</code>下。在这之前，RenderNode是<code>android.view</code>下的Hidden API，而且看了一下Android L的代码和Android P的代码相差还挺大的，反射也不好反射。不过我还是尝试在Android R上使用它。</p>
<h2 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h2><p>应该没人翻译文档吧？稍微翻译一下…</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>RenderNode可用于构建硬件加速绘制体系。每个RenderNode既包含一个DisplayList也包含一系列影响其DisplayList如何绘制在屏幕上的属性。RenderNode在默认情况下在所有View上被内部使用，而并不是直接被使用。<br>RenderNode可用于将一个复杂的绘制场景分开成为更小的部分。这些部分就可以被单独地以更小地开销更新。更新这一场景地一部分只需要更新少数的RenderNode的DisplayList或者属性，而不是重绘所有。一个RenderNode只需要在它的内容被改变时重新录制它的DisplayList。RenderNode可以在不重新录制的情况下通过它的属性进行一些变换。<br>比如说，一个文本编辑器或许会保存每一段到它自己的RenderNode中。这样当用户插入或删除一些字符的时候，只有受影响的段落的DisplayList需要被重新录制。</p>
<h4 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h4><p>RenderNode可以在<code>RecordingCanvas</code>上被绘制。这不受软件绘制支持。请确保你正在使用来绘制RenderNode的Canvas时启用硬件加速的。你可以通过<code>Canvas.isHardwareAccelerated()</code>来确认硬件加速是否可用。</p>
<h4 id="创建RenderNode"><a href="#创建RenderNode" class="headerlink" title="创建RenderNode"></a>创建RenderNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RenderNode</span>(<span class="string">&quot;myRenderNode&quot;</span>);</span><br><span class="line">renderNode.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 设置大小为50*50</span></span><br><span class="line"><span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.beginRecording();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在RenderNode的Canvas上绘制</span></span><br><span class="line">    canvas.drawRect(...);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    renderNode.endRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在View中绘制RenderNode"><a href="#在View中绘制RenderNode" class="headerlink" title="在View中绘制RenderNode"></a>在View中绘制RenderNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated()) &#123;</span><br><span class="line">        <span class="comment">// 检查RenderNode是否有显示列表。如果没有，先重新绘制RenderNode</span></span><br><span class="line">        <span class="keyword">if</span> (!myRenderNode.hasDisplayList()) &#123;</span><br><span class="line">            updateDisplayList(myRenderNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将RenderNode画到Canvas上</span></span><br><span class="line">        canvas.drawRenderNode(myRenderNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>这一步并不是必须的，但是如果你想要尽快释放被DisplayList占用的资源，我们推荐你这么做。最主要的是它或许包含的Bitmap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 舍弃DisplayList，释放持有的资源</span></span><br><span class="line">renderNode.discardDisplayList();</span><br></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除此以外，RenderNode提供了许多属性，比如<code>setScaleX(float)</code>和<code>setTranslationX(float)</code>。他们可以用来影响一切已经记录的绘制命令。例如，这些属性可以被用来移动大量的图像，而不需要重新通过一个一个单独调用<code>canvas.drawBitmap()</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createDisplayList</span><span class="params">()</span> &#123;</span><br><span class="line">    mRenderNode = <span class="keyword">new</span> <span class="title class_">RenderNode</span>(<span class="string">&quot;MyRenderNode&quot;</span>);</span><br><span class="line">    mRenderNode.setPosition(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="type">RecordingCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mRenderNode.beginRecording();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Bitmap b : mBitmaps) &#123;</span><br><span class="line">            canvas.drawBitmap(b, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="literal">null</span>);</span><br><span class="line">            canvas.translate(<span class="number">0.0f</span>, b.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mRenderNode.endRecording();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated())</span><br><span class="line">        canvas.drawRenderNode(mRenderNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveContentBy</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">// 这将移动所有记录在RenderNode中的图像向右边x像素，然后重绘这个View</span></span><br><span class="line">     <span class="comment">// 所有记录的操作不需要被重新发行，只有onDraw()会被调用而且很快就执行完成</span></span><br><span class="line">     mRenderNode.offsetLeftAndRight(x);</span><br><span class="line">     invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：此处笔者觉得用处不大，没翻译<br>A few of the properties may at first appear redundant, such as setElevation(float) and setTranslationZ(float). The reason for these duplicates are to allow for a separation between static &amp; transient usages. For example consider a button that raises from 2dp to 8dp when pressed. To achieve that an application may decide to setElevation(2dip), and then on press to animate setTranslationZ to 6dip. Combined this achieves the final desired 8dip value, but the animation need only concern itself with animating the lift from press without needing to know the initial starting value. setTranslationX(float) and setTranslationY(float) are similarly provided for animation uses despite the functional overlap with setPosition(Rect).<br>The RenderNode’s transform matrix is computed at render time as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Matrix</span> <span class="variable">transform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">transform.setTranslate(renderNode.getTranslationX(), renderNode.getTranslationY());</span><br><span class="line">transform.preRotate(renderNode.getRotationZ(),</span><br><span class="line">        renderNode.getPivotX(), renderNode.getPivotY());</span><br><span class="line">transform.preScale(renderNode.getScaleX(), renderNode.getScaleY(),</span><br><span class="line">        renderNode.getPivotX(), renderNode.getPivotY());</span><br></pre></td></tr></table></figure>
<p>The current canvas transform matrix, which is translated to the RenderNode’s position, is then multiplied by the RenderNode’s transform matrix. Therefore the ordering of calling property setters does not affect the result. That is to say that:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderNode.setTranslationX(<span class="number">100</span>);</span><br><span class="line">renderNode.setScaleX(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>is equivalent to:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderNode.setScaleX(<span class="number">100</span>);</span><br><span class="line">renderNode.setTranslationX(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>RenderNode可以在任何线程被创建并使用，但它不是线程安全的。只有一个线程可以在某一时间与RenderNode交互。建议RenderNode只在相同的线程被使用，即它将要被绘制的线程。比如自定义View使用RenderNode时，只在UI线程使用RenderNode。<br>RenderNode的许多方法返回一个布尔值来指示它是否需要被重绘。典型的比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">translateTo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsUpdate</span> <span class="operator">=</span> myRenderNode.setTranslationX(x);</span><br><span class="line">    needsUpdate |= myRenderNode.setTranslationY(y);</span><br><span class="line">    <span class="keyword">if</span> (needsUpdate) &#123;</span><br><span class="line">        myOwningView.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会比显式地通过<code>getTransationX()</code>比较检查快，因为这最小化了移动到地JNI开销。是否需要重绘取决于这个RenderNode如何被绘制。如果它被绘制到View上，那么只需要重绘View就行了。如果它被绘制到一个直接使用<code>Surface.lockHardwareCanvas()</code>的Canvas上，那么它需要被重绘，通过调用<code>Surface.lockHardwareCanvas()</code>，绘制根RenderNode或者其它被顶级内容需要的，并调用<code>Surface.unlockCanvasAndPost(canvas)</code>。</p>
<h3 id="几个提示"><a href="#几个提示" class="headerlink" title="几个提示"></a>几个提示</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器的name可以随意，null也可以。文档说是调试用的。</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>绘制到View的Canvas上之前，一定要记得检查这个Canvas是否开启硬件加速，如果没有开启，那么RenderNode无法被绘制并且会抛出UnsupportedOperationException。<br>同时也要检查RenderNode是否还有DisplayList，通过<code>RenderNode.hasDisplayList()</code>。如果返回false，需要重新录制在RenderNode上的绘制操作，否则绘制出的RenderNode是空的。<br>RenderNode似乎如果在上一次绘制操作中没有被使用，其DisplayList就会被回收，需要重新录制操作。笔者因为不知道这个傻傻地调了一个小时，最后才发现是没有DisplayList。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><a target="_blank" rel="noopener" href="https://github.com/Rosemoe/CodeEditor/blob/main/editor/src/main/java/io/github/rosemoe/sora/widget/HwAcceleratedRenderer.java">HwAcceleratedRenderer.java</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.rosemoe.cyou">Rosemoe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/">https://blog.rosemoe.cyou/2021/10/02/android-render-node-using/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.rosemoe.cyou" target="_blank">Rosemoe的小博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share" data-image="/img/posts/android-render-node-using/cover.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/10/24/whut-2022-autumn-c-answer/" title="WHUT2022秋C语言A类答案"><img class="cover" src="/img/posts/whut-2022-autumn-c-answer/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">WHUT2022秋C语言A类答案</div></div><div class="info-2"><div class="info-item-1">C理论A_编程练习1-顺序结构主要是一些基础语法，输入输出，和对类型的理解。 7-1 计算整数各位数字之和这里直接用循环实现了。 123456789#include&lt;stdio.h&gt;int main() &#123;    int a, b = 0;    scanf(&quot;%d&quot;, &amp;a);    while (a)        b += a % 10, a /= 10;    printf(&quot;%d&quot;, b);    return 0;&#125; 7-2 计算代数表达式使用内置的数学函数解决 12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define PI 3.14159#define to(x) (x * PI / 180)int main() &#123;    double x;    scanf(&quot;%lf&quot;, &amp;x);    printf(&quot;%.2lf&quot;, sqrt((sin(to(60)) + ...</div></div></div></a><a class="pagination-related" href="/2021/08/22/editor-get-started/" title="Sora-editor - Get started"><img class="cover" src="/img/posts/editor-get-started/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Sora-editor - Get started</div></div><div class="info-2"><div class="info-item-1">PreThe project is fast-moving. This page may not be updated in time. The content of this page may be invalid for newest editor versions. Introductionsora-editor is a optimized editor library with a lot of features on Android.It aims at making more people able to develop their own IDEs with less efforts. Also developing the editor is part of the interest of mine.However its license is LGPL v2.1. Be careful about that.As it is still developing and being tested, there may be some bugs and APIs c...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/04/25/android-dev-mistake/" title="记Android开发中一个坑 - ViewRootImpl"><img class="cover" src="/img/posts/android-dev-mistake/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-25</div><div class="info-item-2">记Android开发中一个坑 - ViewRootImpl</div></div><div class="info-2"><div class="info-item-1">玩Android开发已经两年有余了，一直保持这一些错误思想，终于在前几天给打破了。作为一个开发老者，你一定看过这样的报错： 12android.view.ViewImple$CalledFromWrongThreadException:Only the original thread that created a view hierarchy can touch its views.at android.view.ViewImple.checkThread(ViewImpl.java:xxx) 毫无疑问，八成是你在别的线程尝试对UI进行更新。我们常说那是UI线程之外的线程。但是，为什么报错不是UI thread，而是original呢?我觉得,大多数人都没有想过.前几天看到一篇文章,把我的错误观念打爆了,所以今天记录一下.先来看看checkThread()方法: 123456void checkThread() &#123;       if (mThread != Thread.currentThread()) &#123;           throw new Called...</div></div></div></a><a class="pagination-related" href="/2020/02/15/highlight-editor-creation/" title="一个高亮编辑框的构建历程"><img class="cover" src="/img/posts/highlight-editor-creation/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="info-item-2">一个高亮编辑框的构建历程</div></div><div class="info-2"><div class="info-item-1">前言制作背景我已经在这之前多次写过高亮编辑框了,自从我入门编程以来,就一直在尝试自己造个高亮编辑框的轮子。如果你不想看Rose无聊的背景叙述，请直接从侧栏跳到“本项目的开端”部分。    第一次尝试 - Editable原理这还是在我玩iApp的时候了。当时觉得一个高亮代码编辑框是iApp源码的一大空缺，所以打算造个源码。初次的尝试对Android原生的控件还是抱有很大的期望的。所以选用了Android自带的TextView来制作。众所周知，TextView自己就能显示不同颜色的文本，比如经常看到的链接就是一个例子。所以TextView拿来玩，不存在原理上的问题。因此，我们用Editable来设置文本颜色Spans，并且用TextView显示就好了。我们在文本更新时对高亮进行更新。至于行号，我们只需要编辑框的左边加一个TextView就好了，然后在文本改变时生成文本设置就好了。而滚动，只需要ScrollView和HorizontalScrollView套娃就行了。再者，Spans的匹配只需要轻轻地写个正则表达式Pattern + Matcher就可以匹配了。  过程于是我们造出了...</div></div></div></a><a class="pagination-related" href="/2020/10/30/image-to-qq-painting/" title="👴玩爆QQ涂鸦"><img class="cover" src="/img/posts/image-to-qq-painting/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-30</div><div class="info-item-2">👴玩爆QQ涂鸦</div></div><div class="info-2"><div class="info-item-1">作业原因最近逛b站时发现一个宝藏up主：鉴无虚发QQ涂鸦（uid402778937），他利用QQ不久前更新的涂鸦功能进行创作，绘制了许多有趣的涂鸦，还让粉丝群的成员发送一张图 片，他照着画出来。这让我很羡慕，可是我美术不行，加之用手机画画实在不是一键容易的事，手指太粗，屏幕太小，据up自述，完成一件创造大约需要30min，这让我这个急性子更难受。不过我会一点编程，于是想尝试写一个简单的程序来实现此功能。 过程准备自己使用的手机用的安卓系统，安卓在安卓7.0（Nougat）为辅助功能（AccessibilityService）添加了 1Boolean dispatchGesture(gesture: GestureDescription, callback: AccessibilityService.GestureResultCallback?, handler: Handler?) 来在触摸屏上执行一个手势。我们可以利用这个方法来实现涂鸦的功能。不过原生安卓开发很麻烦，受时间限制，采取跨平台的Auto.js来编写js脚本实现。我把步骤分为两步1读取图片并出来成类似简笔画的效果2在...</div></div></div></a><a class="pagination-related" href="/2020/08/24/what-is-slow-in-text-warrior/" title="Text Warrior中一些不足之处"><img class="cover" src="/img/posts/what-is-slow-in-text-warrior/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="info-item-2">Text Warrior中一些不足之处</div></div><div class="info-2"><div class="info-item-1">前言不少Android项目中，都使用了Text Warrior作为它们的代码编辑器。这个项目的视图是直接继承自View的，与那些继承TextView、EditText的项目不同。使用TextView，我们虽然能够获得较为出色的显示效果，但是在文本较长的时候，会造成卡顿阻碍用户输入，因为我们不得不在主线程中更新我们的Spans，而且每更新一个Span，都会导致TextView重绘。而且经常因为正则表达式不够准确而导致高亮出错。TextWarrior则没有此问题。它收到文本更新的时候，会调用其他线程启动Lexer来刷新高亮，在该线程结束之后刷新绘制，这既保证了高亮的正确性，也保证了UI线程的流畅。然而，它其中有一些不足之处导致大文本仍然不能较快地显示，以及一些用户体验的问题。    绘制问题Span查找问题TextWarrior的Span是用ArrayList，依照顺序依次存起来的，Span中保存了它的Start Index。利用有序的性质，我们可以很快地利用二分将特定Index对应的Span找出来。尤其是在绘制时，这十分有用，直接将O（N）复杂的降到O（log N），很快。但是，目...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rosemoe</div><div class="author-info-description">A lazy Android developer</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Rosemoe"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Rosemoe" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="javascript:copyEmail();" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Rosemoe的小博客~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E5%BA%9F%E8%AF%9D"><span class="toc-number">1.</span> <span class="toc-text">写在前面的废话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6RenderNode%E7%9A%84%E8%B5%B7%E5%9B%A0%E2%80%A6"><span class="toc-number">1.1.</span> <span class="toc-text">研究RenderNode的起因…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%B8%E7%B4%A2TextView%E6%BA%90%E7%A0%81%E2%80%A6"><span class="toc-number">1.2.</span> <span class="toc-text">摸索TextView源码…</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderNode"><span class="toc-number">2.</span> <span class="toc-text">RenderNode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">2.1.</span> <span class="toc-text">文档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">硬件加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BARenderNode"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建RenderNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8View%E4%B8%AD%E7%BB%98%E5%88%B6RenderNode"><span class="toc-number">2.1.3.</span> <span class="toc-text">在View中绘制RenderNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.4.</span> <span class="toc-text">释放资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.5.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.1.6.</span> <span class="toc-text">线程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%8F%90%E7%A4%BA"><span class="toc-number">2.2.</span> <span class="toc-text">几个提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/18/csu-programming-test-2025-2/" title="中南大学2025年第二批预推免机试题解"><img src="/img/posts/csu-programming-test-2025-2/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="中南大学2025年第二批预推免机试题解"/></a><div class="content"><a class="title" href="/2025/10/18/csu-programming-test-2025-2/" title="中南大学2025年第二批预推免机试题解">中南大学2025年第二批预推免机试题解</a><time datetime="2025-10-18T02:28:34.000Z" title="发表于 2025-10-18 10:28:34">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/05/replay-on-a-network-problem-in-contest/" title="校赛防火墙配置导致比赛机器断网问题复盘"><img src="/img/posts/replay-on-a-network-problem-in-contest/cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="校赛防火墙配置导致比赛机器断网问题复盘"/></a><div class="content"><a class="title" href="/2025/07/05/replay-on-a-network-problem-in-contest/" title="校赛防火墙配置导致比赛机器断网问题复盘">校赛防火墙配置导致比赛机器断网问题复盘</a><time datetime="2025-07-05T09:44:10.000Z" title="发表于 2025-07-05 17:44:10">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/xcpc-campus-contest-technically/" title="XCPC 校赛技术筹备指南"><img src="/img/posts/xcpc-campus-contest-technically/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XCPC 校赛技术筹备指南"/></a><div class="content"><a class="title" href="/2025/06/08/xcpc-campus-contest-technically/" title="XCPC 校赛技术筹备指南">XCPC 校赛技术筹备指南</a><time datetime="2025-06-08T02:36:46.000Z" title="发表于 2025-06-08 10:36:46">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/09/codeforces-hacks-on-unordered-map/" title="Codeforces比赛中的unordered_map Hacks"><img src="/img/posts/codeforces-hacks-on-unordered-map/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces比赛中的unordered_map Hacks"/></a><div class="content"><a class="title" href="/2023/08/09/codeforces-hacks-on-unordered-map/" title="Codeforces比赛中的unordered_map Hacks">Codeforces比赛中的unordered_map Hacks</a><time datetime="2023-08-08T16:45:04.000Z" title="发表于 2023-08-09 00:45:04">2023-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/26/codeforces-888/" title="Codeforces Round 888 (Div.3) A-G 题解"><img src="/img/posts/codeforces-888/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 888 (Div.3) A-G 题解"/></a><div class="content"><a class="title" href="/2023/07/26/codeforces-888/" title="Codeforces Round 888 (Div.3) A-G 题解">Codeforces Round 888 (Div.3) A-G 题解</a><time datetime="2023-07-26T07:05:22.000Z" title="发表于 2023-07-26 15:05:22">2023-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2025 By Rosemoe</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text">にゃん~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async src="/js/sideloaded.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-show-text.min.js" data-mobile="true" data-text="にゃん~,喵~" data-fontsize="15px" data-random="true" async="async"></script></div></body></html>